<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Raft算法详解 - xlxing</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="xlxing" />
  <meta name="description" content="名词解释： 非拜占庭：把出现故障但不会伪造信息的错误称为非拜占庭。 拜占庭：把伪造信息恶意响应的情况称为拜占庭。 Raft算法 1.什么是分布式一致" />







<meta name="generator" content="Hugo 0.40.3" />


<link rel="canonical" href="http://xlxing.github.io/post/raft%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.min.css?v=2.5.0" rel="stylesheet">
<link href="https://cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css" rel="stylesheet">


<meta property="og:title" content="Raft算法详解" />
<meta property="og:description" content="名词解释： 非拜占庭：把出现故障但不会伪造信息的错误称为非拜占庭。 拜占庭：把伪造信息恶意响应的情况称为拜占庭。 Raft算法 1.什么是分布式一致" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://xlxing.github.io/post/raft%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" />



<meta property="article:published_time" content="2018-12-03T11:52:05&#43;08:00"/>

<meta property="article:modified_time" content="2018-12-03T11:52:05&#43;08:00"/>











<meta itemprop="name" content="Raft算法详解">
<meta itemprop="description" content="名词解释： 非拜占庭：把出现故障但不会伪造信息的错误称为非拜占庭。 拜占庭：把伪造信息恶意响应的情况称为拜占庭。 Raft算法 1.什么是分布式一致">


<meta itemprop="datePublished" content="2018-12-03T11:52:05&#43;08:00" />
<meta itemprop="dateModified" content="2018-12-03T11:52:05&#43;08:00" />
<meta itemprop="wordCount" content="6814">



<meta itemprop="keywords" content="分布式,算法," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Raft算法详解"/>
<meta name="twitter:description" content="名词解释： 非拜占庭：把出现故障但不会伪造信息的错误称为非拜占庭。 拜占庭：把伪造信息恶意响应的情况称为拜占庭。 Raft算法 1.什么是分布式一致"/>

<!--[if lt IE 9]>
  <script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
  <script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">xlxing</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">xlxing</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Raft算法详解</h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-03
        </span>
        <div class="post-category">
            <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
          </div>
      </div>
    </header>

    
    

    
    <div class="post-content">
      

<h1 id="名词解释">名词解释：</h1>

<p>非拜占庭：把出现故障但不会伪造信息的错误称为非拜占庭。</p>

<p>拜占庭：把伪造信息恶意响应的情况称为拜占庭。</p>

<h1 id="raft算法">Raft算法</h1>

<h2 id="1-什么是分布式一致性">1.什么是分布式一致性？</h2>

<p>分布式系统通常来说都是由分布在不同机器，不同网络上面的多节点构成，每个节点都能够进行独立地计算和存储，节点和节点之间通过网络通信来进行协作。在分布式系统中，多节点的存储方式往往都是通过维护一个个的数据副本，那么我们怎么来保证多节点上的数据副本所维护的数据都是一致的呢？由此就引出了分布式一致性问题，为了解决这一问题就需要有一种一致性算法，所谓的一致性算法就是想让多节点的机器看起来像一个整体一样工作，即使某些节点出现问题。<strong>Raft</strong>算法就是这样一种一致性算法。
&gt; 一致性算法的特性
&gt;
* 确保安全性（从来不返回一个错误的结果），即使在所有的非拜占庭情况下，包括网络延迟、分区、丢包、冗余和乱序的情况下。
* 高可用性，只要集群中的大部分机器都能运行，可以互相通信并且可以和客户端通信，这个集群就可用。因此，一般来说，一个拥有5台机器的集群可以容忍其中2台的失败。
* 不依赖时序保证一致性，物理时钟错误或者极端的消息延迟在最坏的情况下才会引起可用性问题。
* 通常情况下，一条命令能够尽可能快的在大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。</p>

<h3 id="1-1-复制状态机">1.1 复制状态机</h3>

<p><img src="http://image.gamelaoyou.com/img/201812/3f4241a460720794dcdc7dd1.png" alt="" /></p>

<p>如图所示，复制状态机通常都是基于复制日志实现的，每个状态机按照日志的顺序来处理一致性模块中接收到的客户端请求；保证日志相同就是一致性算法的工作了。</p>

<h2 id="2-raft基本概念与组成">2.Raft基本概念与组成</h2>

<p>Raft是一种为了管理复制日志的一致性算法，它提供了和*Paxos算法*（另外一种一致性算法，较为晦涩难懂，Raft的诞生就是为了让算法理解起来更简单）相同的功能和性能，但它的算法结构和Paxos不同。为了提升整个算法的可理解性，Raft将一致性算法分解成了几个模块：领导人选举、日志复制和安全性。</p>

<ul>
<li><strong>领导选举：</strong>一个新的领导人需要选举出来，当现存的领导宕机或者不存在领导人的时候。</li>
<li><strong>日志复制：</strong>领导人必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其他节点的日志跟自己保持相同。</li>
<li><strong>安全性：</strong>如果有任何服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一日志索引位置应用一个不同的指令。</li>
</ul>

<h3 id="2-1-领导选举">2.1 领导选举</h3>

<p>节点中三大身份</p>

<ul>
<li><strong>leader（领导人）</strong>：整体协调者，对外服务唯一接口，对内数据统一的发起者。</li>
<li><strong>follower（跟随者）</strong>：被动接受来自leader的数据请求。</li>
<li><strong>candidate（候选人）</strong>：临时角色，只存在于leader的选举阶段。</li>
</ul>

<p>各个节点维护的状态</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>currentTerm</td>
<td>服务器最后一次知道的任期号（初始化为0，持续递增）（持久存在）</td>
</tr>

<tr>
<td>votedFor</td>
<td>在当前获得选票的候选人的Id（持久存在）</td>
</tr>

<tr>
<td>log[]</td>
<td>日志条目集；每一个条目包含一个用户状态机执行的指令和收到时的任期号（持久存在）</td>
</tr>

<tr>
<td>commitIndex</td>
<td>已知的最大的已经被提交的日志条目的索引值（经常变化）</td>
</tr>

<tr>
<td>lastApplied</td>
<td>最后被应用到状态机的日志条目索引值（初始化为0，持续递增）（经常变化）</td>
</tr>

<tr>
<td>nextIndex[]</td>
<td>对于每一个服务器，需要发送给它的下一个日志条目的索引值（初始化为领导人最后索引值加一）（在领导人里经常改变的，选举后重新初始化）</td>
</tr>

<tr>
<td>matchIndex[]</td>
<td>对于每一个服务器，已经复制给他的日志的最高索引值（在领导人里经常改变的，选举后重新初始化）</td>
</tr>
</tbody>
</table>

<p><img src="http://image.gamelaoyou.com/img/201812/bacebfe7bd42ffcf4d6686ff.png" alt="" /></p>

<pre><code>                                图1：转换关系图
</code></pre>

<p>任期：</p>

<p><img src="http://image.gamelaoyou.com/img/201812/6992232b3fe47c11ec441bf0.png" alt="" /></p>

<pre><code>                                图2：任期图
</code></pre>

<p>任期是指一台服务器作为leader的时间，随着时间的推移，每一个服务器都有称为leader的可能。t3阶段表示选主失败（至于为什么会选主失败后面我们会提到），到t4继续进行选主操作。</p>

<h4 id="2-1-1-蓝色部分-选主">2.1.1 蓝色部分：选主</h4>

<h5 id="2-1-1-1-触发选主">2.1.1.1 触发选主</h5>

<p>如何触发选主我们就要借助图1来进行说明：</p>

<p>每个服务器节点在起始状态都是follower身份，同时每个follower要正常的保持自己的角色就需要从leader或者candidate那里接收有效的RPC请求（leader为了保证自己的领导地位会周期性地向各个节点发送心跳包），如果超过一段时间没有收到消息，那么follower就会认为系统中不存在leader，这时候就会发起leader选举。</p>

<h5 id="2-1-1-2-选举过程">2.1.1.2 选举过程</h5>

<p>投票RPC请求参数说明：</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>term</td>
<td>候选人任期号</td>
</tr>

<tr>
<td>candidateId</td>
<td>请求选票的候选人Id</td>
</tr>

<tr>
<td>lastLogIndex</td>
<td>候选人的最后日志条目的索引值</td>
</tr>

<tr>
<td>lastLogTerm</td>
<td>候选人最后日志条目的任期号</td>
</tr>
</tbody>
</table>

<p>返回值：</p>

<table>
<thead>
<tr>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>term</td>
<td>当前任期号，以便于候选人去更新自己的任期号</td>
</tr>

<tr>
<td>voteGranted</td>
<td>候选人赢得了此张选票时为真</td>
</tr>
</tbody>
</table>

<p>投票人实现规则：</p>

<ul>
<li>如果term&lt;currentTerm返回false。</li>
<li>如果voteFor为空或者就是candidateId，并且候选人的日志至少和自己一样新，那么就投票给它。</li>
</ul>

<p><img src="http://image.gamelaoyou.com/img/201812/3d96d648e71ca44c836dcbd7.png" alt="" /></p>

<p>follower&mdash;(发起选主)&mdash;&gt;candidate&mdash;(请求投票)&mdash;&gt;超过半数，称为新leader</p>

<p>follower&mdash;(发起选主)&mdash;&gt;candidate&mdash;(请求投票)&mdash;&gt;检测到有新的leader产生，退回follower</p>

<p>follower&mdash;(发起选主)&mdash;&gt;candidate&mdash;(请求投票)&mdash;&gt;一段时间内没有人获胜，重新发起选主投票</p>

<p>Raft算法为了防止第三种情况的重复出现造成无法选主的情况，采用了随机选举超时时间（例如150-300毫秒，这个时间是官方给出的最佳随机时间范围）的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。官方经过了大量的测试数据证明了这种方案可以快速的选出新的领导人，同时这种随机重试的方法更加明显和易于理解。</p>

<h4 id="2-1-2-绿色部分-leader任期">2.1.2 绿色部分：leader任期</h4>

<p>leader一旦被选举出来就需要为client提供服务，当client发出请求的时候leader需要同步请求个其他服务器节点，同时为了保持自己的任期还需要周期性不停地向其他服务器节点发送心跳包。这里就引出了日志复制的概念。</p>

<h3 id="2-2-日志复制">2.2 日志复制</h3>

<p>客户端的每一个请求都包含一条被复制状态机执行的指令。领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行的发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目。当这条日志条目被安全的复制（下面会介绍），领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目 RPC（尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。</p>

<p><img src="http://image.gamelaoyou.com/img/201812/ed4638fbd2896027e1d84874.png" alt="" /></p>

<p>日志以上图的方式组织。每一条日志条目存储一条状态机指令和从领导人收到这条指令时的任期号。日志中的任期号用来检查是否出现不一致的情况，同时也用来保证了一定的安全性。每一条日志条目同时也都有一个整数索引来表明它在日志中的位置。</p>

<p>leader会决定什么时候将日志条目应用到状态机中是安全的，这样的日志条目被称为<strong>已提交</strong>。在leader将日志条目复制到大多数的服务器上的时候，日志条目就会被提交。同时，leader的日志中之前的所有日志条目也都会被提交，包括由其他leader创建的条目。</p>

<p>这样的提交方式被称为二阶段提交。</p>

<h4 id="2-2-1-二阶段提交-two-phasecommit-概念">2.2.1 二阶段提交（Two-phaseCommit）概念：</h4>

<ol>
<li><p>请求阶段（表决）：</p>

<p>事务协调者通知每个参与者准备提交或取消事务，然后进入表决过程，参与者要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种&rdquo;万事俱备，只欠东风&rdquo;的状态。请求阶段，参与者将告知协调者自己的决策: 同意(事务参与者本地作业执行成功)或取消（本地作业执行故障）</p></li>

<li><p>提交阶段（执行）：</p>

<p>在该阶段，写调整将基于第一个阶段的投票结果进行决策: 提交或取消。当且仅当所有的参与者同意提交事务（Raft只需要大多是节点同意），协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务，参与者在接收到协调者发来的消息后将执行响应的操作。</p></li>
</ol>

<p>附加日志RPC请求：</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>term</td>
<td>领导人的任期号</td>
</tr>

<tr>
<td>leaderId</td>
<td>领导人的Id，以便于follower重定向请求</td>
</tr>

<tr>
<td>prevLogIndex</td>
<td>新的日志条目紧随之前的索引值</td>
</tr>

<tr>
<td>prevLogTerm</td>
<td>prevLogIndex条目的任期号</td>
</tr>

<tr>
<td>entries[]</td>
<td>准备存储的日志条目（表示心跳时为空；一次性发送多个是为了提高效率）</td>
</tr>

<tr>
<td>leaderCommit</td>
<td>领导人已经提交的日志的索引值</td>
</tr>
</tbody>
</table>

<p>返回参数：</p>

<table>
<thead>
<tr>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>term</td>
<td>当前的任期号，用于领导人去更新自己</td>
</tr>

<tr>
<td>success</td>
<td>跟随者包含了匹配上prevLogIndex和prevLogTerm的日志时为真</td>
</tr>
</tbody>
</table>

<p>follower实现规则：</p>

<ul>
<li>如果term&lt;currentTerm就返回false。</li>
<li>如果日志在prevLogIndex位置处的日志条目的任期号和prevLogTerm不匹配就返回false。</li>
<li>如果已经存在的日志条目和新的产生冲突（索引值相同但是任期号不同），删除这一行和之后的所有。</li>
<li>附加任何在已有的日志中不存在的条目。</li>
<li>如果leaderCommit&gt;commitIndex，令commitIndex等于leaderCommit和新日志条目索引值中较小的一个。</li>
</ul>

<p>leader跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志 RPCs （包括心跳包），这样其他的服务器才能最终知道leader的提交位置。一旦follower知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。</p>

<p><img src="http://image.gamelaoyou.com/img/201812/a4ef97e41f68d055fab6fdaa.png" alt="" /></p>

<p>正常情况下，leader和follower的日志都是保持一致的，但是leader崩溃就会造成日志处于不一致的状态（旧的leader可能还没有完全复制所有的日志条目），上图展示了follower和新的leader不同的日志条目方式。</p>

<p>在Raft算法中，leader处理这种不一致是通过强制跟随者直接复制自己的日志来解决的。</p>

<h4 id="2-2-2-解决不一致方案">2.2.2 解决不一致方案</h4>

<p>leader针对每一个follower都维护了一个nextIndex，这表示下一个需要发送给follower的日志条目索引。如果follower的日志和leader不一致，那么在下一次的附加日志RPC时的一致性检测就会失败，这时候leader就会减小nextIndex的值然后重试，直到和follwer达成一致，这时候follower就会将冲突的日志条目全部删除然后附加上leader的日志条目，这样就重新保持一致。</p>

<h3 id="2-3-安全性">2.3 安全性</h3>

<p>前面我们已经介绍了选举和日志复制，但是到目前为止，我们始终还是无法保证每一个状态机都会按照相同的顺序执行相同的指令。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。</p>

<p>Raft算法为了解决类似的这些问题，添加了一系列的限制条件：</p>

<h4 id="2-3-1-选举限制">2.3.1 选举限制</h4>

<p>Raft在进行投票的时候，candidate发起投票请求的时候会将自己最新的一条日志的索引值和任期号带上，收到投票请求的服务节点，会将自己的日志比对来判断candidate所包含的日志条目是否比自己新，这时候服务器节点才会将票投出去，所以当收到大多数服务器的投片的candidate一定就持有了所有已经提交的日志条目。</p>

<p>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</p>

<h4 id="2-3-2-提交之前任期内的日志条目">2.3.2 提交之前任期内的日志条目</h4>

<p><img src="http://image.gamelaoyou.com/img/201812/b038290982bba5461b2cc34c.png" alt="" /></p>

<p>上图展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。</p>

<p>如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交。
在 (a) 中，S1 是领导者，部分的复制了索引位置 2 的日志条目。</p>

<p>在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。</p>

<p>然后到 &copy;，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。</p>

<p>如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。</p>

<p>反之，如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。</p>

<p>上图所示的问题出现的根本原因发生在（c）阶段S1崩溃后S5当选了新的leader，要解决这个问题就是让S5失去称为新leader的机会，在（c）中S1优先去复制了来自任期2的那条日志，这时候如果我们通过复制提交任期4的那条日志间接地去提交任期2的日志就会让S5失去选举的机会。</p>

<p>Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有leader当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。</p>

<h4 id="2-3-3-安全性论证">2.3.3 安全性论证</h4>

<p>我们假设领导人完全性特性是不存在的，然后我们推出矛盾来。假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。
<img src="http://image.gamelaoyou.com/img/201812/fb64aa9b5ef965339470d94d.png" alt="" /></p>

<p>通过反证法推出矛盾,领导人U不可能被选举为领导人，三处矛盾：
1. 投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。
2. 如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。
3. 除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交当然日志，这里产生矛盾。</p>

<h2 id="3-follower和candidate崩溃处理">3.follower和candidate崩溃处理</h2>

<p>上述的我们只说明了leader的崩溃处理，follower和candidate的崩溃处理其实更简单，他们崩溃后leader发出的RPC都会失败，这时候leader就后一直重试直到成功，当follower和candidate重新恢复收到RPC请求后就是快速的同步日志达到一致性，发出的RPC都是幂等的，所以leader发出的重试根本不会有什么影响。</p>

<h2 id="4-集群成员变化-增加机器节点">4.集群成员变化（增加机器节点）</h2>

<h2 id="5-日志压缩">5.日志压缩</h2>

<p>日志清理或者日志结构合并</p>

<h2 id="6-客户端交互">6.客户端交互</h2>

<p>Raft 中的客户端发送所有请求给领导人。当客户端启动的时候，他会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供他最近接收到的领导人的信息（附加条目请求包含了领导人的网络地址）。如果领导人已经崩溃了，那么客户端的请求就会超时；客户端之后会再次重试随机挑选服务器的过程。</p>

<p>我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在他调用和收到回复之间）。但是，如上述，Raft 是可以执行同一条命令多次的：例如，如果领导人在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新的领导人重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。</p>

<p>只读的操作可以直接处理而不需要记录日志。但是，在不增加任何限制的情况下，这么做可能会冒着返回脏数据的风险，因为领导人响应客户端请求时可能已经被新的领导人作废了，但是他还不知道。线性化的读操作必须不能返回脏数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。首先，领导人必须有关于被提交日志的最新信息。领导人完全特性保证了领导人一定拥有所有已经被提交的日志条目，但是在他任期开始的时候，他可能不知道那些是已经被提交的。为了知道这些信息，他需要在他的任期里提交一条日志条目。Raft 中通过领导人在任期开始的时候提交一个空白的没有任何操作的日志条目到日志中去来实现。第二，领导人在处理只读的请求之前必须检查自己是否已经被废黜了（他自己的信息已经变脏了如果一个更新的领导人被选举出来）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。可选的，领导人可以依赖心跳机制来实现一种租约的机制，但是这种方法依赖时间来保证安全性（假设时间误差是有界的）。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
          
          <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
          
        </div>

      
      <nav class="post-nav">
        
        
          <a class="next" href="/post/golang%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89%E4%B8%AD%E6%96%87%E6%89%80%E5%9C%A8%E8%A1%8C%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/">
            <span class="next-text nav-default">Golang实现的一个扫描指定文件夹下所有中文所在行的小工具</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
      </div>  
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
        <a href="mailto:xianglixingff@126.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/xlxing" class="iconfont icon-github" title="github"></a>
  <a href="http://xlxing.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="copyright-year">
    &copy; 
    
      2017 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">xlxing</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js"></script>
<script type="text/javascript" src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdn.bootcss.com/slideout/1.0.1/slideout.min.js"></script>
  <script type="text/javascript" src="https://cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="/dist/even.min.js?v=2.5.0"></script>






</body>
</html>
